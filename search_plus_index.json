{"./":{"url":"./","title":"relax-space","keywords":"","body":"relax space 我搬起砖无法拥抱你，我拥抱你，却无法养活你 "},"tech/":{"url":"tech/","title":"技术","keywords":"","body":" 技术 mysql rocketmq "},"tech/mysql/m1.html":{"url":"tech/mysql/m1.html","title":"mysql","keywords":"","body":"1 "},"tech/rocketmq/m1.html":{"url":"tech/rocketmq/m1.html","title":"rocketmq","keywords":"","body":"介绍一些概念 Topic 一级消息类型 tag 在Topic类别下的二级子类别 Group Producer Group（生产者组） Consumer Group（消费者组） 举几个例子简单说一下使用： 例子对象 表头 produce配置 consume配置 说明 Topic例子 只区分topic的模式 Topic：fruitTag：allgroupId：any Topic：fruitTag：allgroupId：any 生产者：发送水果接收者：接收所有消息（所有水果） Tag例子 会区分tag Topic：fruitTag：apple&&peargroupId：any Topic：fruitTag：applegroupId：anyTopic：fruitTag：peargroupId：anyTopic：fruitTag：apple&&peargroupId：any 生产者：发送水果（只发送苹果和梨子）接收者：● 只有1个接受者：可以选择只接受apple，或只接收pear● 有多个接受者：必须保证多个接受者的tag一致，要么都接受apple，要么都接受pear，要么都接受apple和pear group例子 会区分groupId，两个消费者接收同一个消息。假如两个消费者的groupId一样，那么最终只有一个消费者能消费到消息,如果groupId不一样，则两个消费者都能接收到消息 Topic：fruitTag：applegroupId：abc Topic：fruitTag：applegroupId：c1Topic：fruitTag：applegroupId：c2 生产者：发送苹果接收者1：接收苹果接收者2：也接收苹果 "},"tool/":{"url":"tool/","title":"工具","keywords":"","body":" 工具 git rebase idea jrebel git本地改变 navicat system 代理 ssh vscode 大小写快捷键 代理 windows ip切换工具 pin 自动同步时间 "},"tool/git/m1.html":{"url":"tool/git/m1.html","title":"git","keywords":"","body":""},"tool/git/rebase/m1.html":{"url":"tool/git/rebase/m1.html","title":"rebase","keywords":"","body":"rebase pull的时候默认rebase，而不是merge # 新创建项目管用 git config --global branch.autosetuprebase always # 旧项目也管用 git config --global pull.rebase true "},"tool/idea/m1.html":{"url":"tool/idea/m1.html","title":"idea","keywords":"","body":"1 "},"tool/idea/jrebel/m1.html":{"url":"tool/idea/jrebel/m1.html","title":"jrebel","keywords":"","body":"jrebel 一个idea的插件 说明 在idea上修改java代码之后，不需要重启，直接按 ctrl +shift + F9 即可生效，本地调试的时候，可以节约很多时间 安装idea插件 JRebel and XRebel for IntelliJ JRebel mybatisPlus extension激活 step1 下载和运行反向代理 下载地址：https://github.com/ilanyu/ReverseProxy/releases/latest step2 生成GUID https://www.guidgen.com/ step3 用这个网址 + 生成的 GUID 激活 http://0.0.0.0:8888 例如: http://0.0.0.0:8888/738b776f-6cc9-4ac5-9574-960a057392db step4:设置离线模式 来防止失效 参考 https://cloud.tencent.com/developer/article/1642800 "},"tool/idea/git/m1.html":{"url":"tool/idea/git/m1.html","title":"git本地改变","keywords":"","body":"idea自带的git 显示git的改动记录 settings/Version Control/Commit 不要选中 Use non-modal commit interface settings/Tools/Settings Repository 不要选中 Auto Sync settings/Editor/File Encodings 都设置为utf8（共3个地方），主要是为了防止乱码 "},"tool/navicat/m1.html":{"url":"tool/navicat/m1.html","title":"navicat","keywords":"","body":"1 "},"tool/system/m1.html":{"url":"tool/system/m1.html","title":"system","keywords":"","body":""},"tool/system/proxy/m1.html":{"url":"tool/system/proxy/m1.html","title":"代理","keywords":"","body":"设置代理 bash export http_proxy=http://127.0.0.1:8001 export https_proxy=http://127.0.0.1:8001 unset http_proxy unset https_proxy cmd set http_proxy=http://127.0.0.1:8001 set https_proxy=http://127.0.0.1:8001 set http_proxy= set https_proxy= powershell Function Set-InternetProxy { [CmdletBinding()] Param( [Parameter(Mandatory=$True,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)] [String[]]$Proxy, [Parameter(Mandatory=$False,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)] [AllowEmptyString()] [String[]]$acs ) Begin { $regKey=\"HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\" } Process { Set-ItemProperty -path $regKey ProxyEnable -value 1 Set-ItemProperty -path $regKey ProxyServer -value $proxy if($acs) { Set-ItemProperty -path $regKey AutoConfigURL -Value $acs } } End { Write-Output \"Proxy is now enabled\" Write-Output \"Proxy Server : $proxy\" if ($acs) { Write-Output \"Automatic Configuration Script : $acs\" } else { Write-Output \"Automatic Configuration Script : Not Defined\" } } } Set-InternetProxy -proxy \"127.0.0.1:8001\" Function Disable-InternetProxy { Begin { $regKey=\"HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\" } Process { Set-ItemProperty -path $regKey ProxyEnable -value 0 -ErrorAction Stop Set-ItemProperty -path $regKey ProxyServer -value \"\" -ErrorAction Stop Set-ItemProperty -path $regKey AutoConfigURL -Value \"\" -ErrorAction Stop } End { Write-Output \"Proxy is now Disabled\" } } Disable-InternetProxy 测试是否成功 curl google.com StatusCode : 200 StatusDescription : OK Content : "},"tool/system/ssh/m1.html":{"url":"tool/system/ssh/m1.html","title":"ssh","keywords":"","body":"ssh创建和使用 创建ssh ssh-keygen -t ed25519 -C \"xiaoxm_001@outlook.com\" -f ~/.ssh/github 注: -f是可选的，如果不写，默认放到~/.ssh/id_rsa 复制公钥到github cat ~/.ssh/github.pub 修改config文件 如果没有就创建, 有就追加 vim ~/.ssh/config 追加的内容如下: Host github.com User relax-admin Port 22 IdentityFile /c/Users/Administrator/.ssh/github 从github下载私有仓库 git clone git@github.com:relax-space/tmall-cookie-fetch.git 参考 https://docs.github.com/cn/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent 问题 问题1: ssh: connect to host github.com port 22: Connection timed out 方案: 修改config文件 Host github.com Hostname ssh.github.com User relax-admin Port 443 IdentityFile /c/Users/Administrator/.ssh/github "},"tool/system/hotkey.html":{"url":"tool/system/hotkey.html","title":"快捷键","keywords":"","body":"win键被锁 搜索电脑型号 win键被锁 即可 比如: 我的是机械革命的电脑, 那么就按fn+f2 虽然,只有一句话,但是管用!! "},"tool/vscode/m1.html":{"url":"tool/vscode/m1.html","title":"vscode","keywords":"","body":"vscode "},"tool/vscode/case/m1.html":{"url":"tool/vscode/case/m1.html","title":"大小写快捷键","keywords":"","body":"大小写快捷键 路径：File -> Perferences -> Settings -> Keyboard Shortcuts 操作： 删除已有的快捷键 ctrl+shift+u 和 ctrl+u 点击右上角按钮，进入json格式，复制下面的内容，即可 // Place your key bindings in this file to overwrite the defaults [ { \"key\": \"ctrl+shift+u\", \"command\": \"editor.action.transformToUppercase\" }, { \"key\": \"ctrl+u\", \"command\": \"editor.action.transformToLowercase\" } ] "},"tool/vscode/proxy/m1.html":{"url":"tool/vscode/proxy/m1.html","title":"代理","keywords":"","body":"vscode设置代理 路径：File -> Perferences -> Settings 然后搜索框中搜索：proxy 在Http：proxy下面填写 http://localhost:8001 当然，前提是自己购买了代理 效果：以下是go语言安装包的效果 Tools environment: GOPATH=C:\\Users\\Administrator\\go Installing 10 tools at C:\\Users\\Administrator\\go\\bin in module mode. gopkgs go-outline gotests gomodifytags impl goplay dlv dlv-dap staticcheck gopls Installing github.com/uudashr/gopkgs/v2/cmd/gopkgs@latest (C:\\Users\\Administrator\\go\\bin\\gopkgs.exe) SUCCEEDED Installing github.com/ramya-rao-a/go-outline@latest (C:\\Users\\Administrator\\go\\bin\\go-outline.exe) SUCCEEDED Installing github.com/cweill/gotests/gotests@latest (C:\\Users\\Administrator\\go\\bin\\gotests.exe) SUCCEEDED Installing github.com/fatih/gomodifytags@latest (C:\\Users\\Administrator\\go\\bin\\gomodifytags.exe) SUCCEEDED Installing github.com/josharian/impl@latest (C:\\Users\\Administrator\\go\\bin\\impl.exe) SUCCEEDED Installing github.com/haya14busa/goplay/cmd/goplay@latest (C:\\Users\\Administrator\\go\\bin\\goplay.exe) SUCCEEDED Installing github.com/go-delve/delve/cmd/dlv@latest (C:\\Users\\Administrator\\go\\bin\\dlv.exe) SUCCEEDED Installing github.com/go-delve/delve/cmd/dlv@master (C:\\Users\\Administrator\\go\\bin\\dlv-dap.exe) SUCCEEDED Installing honnef.co/go/tools/cmd/staticcheck@latest (C:\\Users\\Administrator\\go\\bin\\staticcheck.exe) SUCCEEDED Installing golang.org/x/tools/gopls@latest (C:\\Users\\Administrator\\go\\bin\\gopls.exe) SUCCEEDED 引用： http://www.meilongkui.com/archives/828 "},"tool/windows/m1.html":{"url":"tool/windows/m1.html","title":"windows","keywords":"","body":""},"tool/windows/ipSwitch/m1.html":{"url":"tool/windows/ipSwitch/m1.html","title":"ip切换工具","keywords":"","body":"切换ip工具 适用 win10 winx 效果 制作 创建一个空的auto.bat文件，复制下面的内容，记得修改以下参数 NAME、ADDR、MASK、GATEWAY、DNS1、DNS2 注：NAME一般默认就行，如果不确定可以去这里了找： 网络和Internet里-> 更改适配器选项 @echo off rem //设置变量 set NAME=\"WLAN\" rem //以下属性值可以根据需要更改 set ADDR=192.168.40.43 set MASK=255.255.255.0 set GATEWAY=192.168.40.253 set DNS1=233.5.5.5 set DNS2=10.23.10.9 rem //以上属性依次为IP地址、子网掩码、网关、首选DNS、备用DNS :4 echo 当前可用操作有： echo 1 设置为静态IP echo 2 设置为动态IP echo 3 退出 echo 请选择后回车： set /p operate= if %operate%==1 goto 1 if %operate%==2 goto 2 if %operate%==3 goto 3 :1 echo 正在设置静态IP，请稍等... rem //可以根据你的需要更改 echo IP地址 = %ADDR% echo 掩码 = %MASK% echo 网关 = %GATEWAY% netsh interface ipv4 set address %NAME% static %ADDR% %MASK% %GATEWAY% echo 首选DNS = %DNS1% netsh interface ipv4 set dns %NAME% static %DNS1% echo 备用DNS = %DNS2% if \"%DNS2%\"==\"\" (echo DNS2为空) else (netsh interface ipv4 add dns %NAME% %DNS2%) echo 静态IP已设置！ pause goto 4 :2 echo 正在设置动态IP，请稍等... echo 正在从DHCP自动获取IP地址... netsh interface ip set address %NAME% dhcp echo 正在从DHCP自动获取DNS地址... netsh interface ip set dns %NAME% dhcp echo 动态IP已设置！ pause goto 4 :3 exit 使用 右键 以管理员身份运行 "},"tool/windows/pin/m1.html":{"url":"tool/windows/pin/m1.html","title":"pin","keywords":"","body":"windows 无法删除快速访问文件夹 方案： %APPDATA%\\Microsoft\\Windows\\Recent\\AutomaticDestinations %APPDATA%\\Microsoft\\Windows\\Recent\\CustomDestinations 删除以上文件夹中的所有内容，使快速访问栏恢复初始状态 引用：https://www.jianshu.com/p/ab197e815282 "},"tool/windows/time/m1.html":{"url":"tool/windows/time/m1.html","title":"自动同步时间","keywords":"","body":"window 10 自动同步时间 打开cmd（管理员） 这里需要三个命令配合完成，首先可以重置用户策略（执行后无说明）： rd /s /q \"%windir%\\System32\\GroupPolicyUsers\" 然后可以重置本地组策略，包括计算机配置和用户配置（执行后无说明）： rd /s /q \"%windir%\\System32\\GroupPolicy\" 这两个执行之后，使用如下强制更新命令让上述重置操作生效（执行成功后会有提示）： gpupdate /force "},"docker/":{"url":"docker/","title":"docker","keywords":"","body":" docker it命令 "},"docker/it/m1.html":{"url":"docker/it/m1.html","title":"it命令","keywords":"","body":"运行镜像,并进入 在docker的linux环境运行python代码 docker pull python:alpine docker run -it -v /d/1.source/pythonpath/python-learning/utils:/data1 python:alpine /bin/sh python data1/zone.py windows文件路径:/d/1.source/pythonpath/python-learning/utils/zone.py zone.py from datetime import datetime print(datetime.now()) "},"java/":{"url":"java/","title":"java","keywords":"","body":" java maven 序列化 基础1 "},"java/maven/m1.html":{"url":"java/maven/m1.html","title":"maven","keywords":"","body":"通用settings文件 先从阿里云下载，如果没有则从maven官方版本库下载 aliyunmaven central 阿里云公共仓库 https://maven.aliyun.com/repository/central repo1 central central repo https://repo1.maven.org/maven2/ aliyunmaven apache snapshots 阿里云阿帕奇仓库 https://maven.aliyun.com/repository/apache-snapshots aliyunmaven aliyunmaven https://maven.aliyun.com/repository/public default true true MavenCentral https://repo1.maven.org/maven2/ aliyunmavenApache https://maven.aliyun.com/repository/apache-snapshots "},"java/fastjson/m1.html":{"url":"java/fastjson/m1.html","title":"序列化","keywords":"","body":"序列化测试 说明 序列化对象：fastjson比java流序列化快1倍 序列化集合：java流序列化比fastjson快3倍 测试结果 JSONObject测试 100万 第1次 100万 第2次 100万 第3次 fastjson 75 70 83 java流 169 166 177 // fastjson byte[] b1 = JSONObject.toJSONBytes(ipBTaobaoOrder); IpBTaobaoOrder b2 = JSONObject.parseObject(b1, IpBTaobaoOrder.class); // java流 byte[] b1 = ObjectUtil.objectSerialize(ipBTaobaoOrder); IpBTaobaoOrder b2 = (IpBTaobaoOrder) ObjectUtil.objectDeserialize(b1); public class ObjectUtil { public static Object objectDeserialize(byte[] bytes) throws IOException, ClassNotFoundException { ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); ois.close(); bais.close(); return ois.readObject(); } public static byte[] objectSerialize(Object object) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(object); oos.close(); baos.close(); return baos.toByteArray(); } } JSONArray测试 100万 第1次 100万 第2次 100万 第3次 fastjson 68 65 65 java流 17 17 17 // fastjson byte[] b1 = JSONObject.toJSONBytes(ipBTaobaoOrderList); JSONArray bb = (JSONArray) JSONObject.parse(b1); List b2 = bb.toJavaList(IpBTaobaoOrder.class); // java流 byte[] b1 = ObjectUtil.objectSerialize(ipBTaobaoOrderList); List b2 = (List) ObjectUtil.objectDeserialize(b1); 硬件信息如下： Operating System: Windows 10 企业版 64-bit (10.0, Build 18362) (18362.19h1_release.190318-1202) System Model: Latitude E5570 Processor: Intel(R) Core(TM) i5-6300U CPU @ 2.40GHz (4 CPUs), ~2.5GHz Memory: 32768MB RAM 详情 https://github.com/relax-space/serialize-test "},"java/base1/m1.html":{"url":"java/base1/m1.html","title":"基础1","keywords":"","body":"基础总结 字符串不可变 String a =\"111\" 会放到常量池 String b= new String(\"222\") 会放到堆中，会创建两个对象，一个放到常量池，一个放到堆中 String a1 =\"ab\"; String a2=\"a\"+\"b\";// a2 a1内存地址一样 String a3=\"a\" String b3=a3+\"b\";// b3 a1内存地址不一样 常量池 常量池：基本类型（Byte,Short,Integer,Long,Character,Boolean），对象型（String和数组），常量值：final Float,Double不在常量池中 StringBuilder StringBuilder 线程不安全，速度快 StringBuffer线程安全 数据类型 基本数据类型：六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。 byte,short,char—> int —> long—> float —> double byte 8位 short、char 16位 int、float 32位 变量 变量：类变量、实例变量、局部变量 局部变量： 类的方法中的变量 在方法（构造函数、语句块）执行的时候创建，执行完成后销毁 实例变量： 独立于方法之外的变量，不用static修饰 存储在堆内存中 实例变量，在对象创建的时候创建，对象销毁的时候销毁 类变量： 独立于方法之外的变量，用static修饰 类变量存储在静态区，全局共享 集合 collection：List、Set、queue、map Map：ArrayList、LinkedList、HashSet、LinkedHashset、HashMap、LinkedHashMap 经常查询用 arrayList，插入和删除多用linkedlist LinkedList、ArrayList、HashSet、HashMap、StringBuilder是非线程安全的 Vector、HashTable、StringBuffer是线程安全的。 数据结构：哈希表、链表、树、栈、堆、数组 hashmap源码 hashmap： 数组+链表 存储数据量大于初始容量*加载因子则扩容 put 先从数组中，判断hash是否存在，如果不存在直接赋值 然后再判断链表表头中key是否相同，如果不存在直接赋值 然后，遍历链表，如果key不相同，则赋值 如果存在，断开循环，最后赋值 get 先从数组中找hash，如果存在并key相等则返回 如果不存在，并且不止一个元素，就遍历链表，直到找到key相同的节点 如果不存在，则返回null http://www.noobyard.com/article/p-tlafxuqh-mu.html "},"python/":{"url":"python/","title":"python","keywords":"","body":" python 协程 yield yield_from async await yield中断 async中断 yield并发 await并发 asyncio源码解析 asyncio体验 asyncio实战 进程 process例子 process_executor例子 process cpu测试 process cpu测试2 process lock process+协程 线程 thread简单例子 线程安全 线程池 锁 condition semaphore例子 event例子 condition理解 清华源 时区 邮件 字符串 参数 字典 列表 集合 正则 序列化 pypy安装 "},"python/source/m1.html":{"url":"python/source/m1.html","title":"清华源","keywords":"","body":"临时使用 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package 设置默认 pip install pip -U pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 引用 https://mirrors.tuna.tsinghua.edu.cn/help/pypi/ "},"python/zone/m1.html":{"url":"python/zone/m1.html","title":"时区","keywords":"","body":"时区 问题:同样的代码，linux上的时间 比window上的时间少8小时，如何统一都显示为中国时区的时间？ 分析：天涯共此时，我在中国的电脑上执行print(datetime.now()),打印的是2021-12-23 18:00:00, 同时，有一个格林威治的人，也在电脑上运行了同样的语句，他电脑上应打印肯定是他们当地的时间：2021-12-23 10:00:00 所以，我想要格林威治的人也打印中国时间怎么办？告诉他时区即可 from datetime import datetime, timedelta, timezone TZ = timezone(timedelta(hours=8)) # 你将在全世界任何一个时区的电脑上，都打印的是中国时间，可以把下面的代码在linux上执行看结果 print(datetime.now(TZ)) 测试linux时间 我是用docker下载了python，然后进入里面执行， 其中/d/1.source/pythonpath/python-learning/utils 是我windows的本地文件夹，进入容器之后，执行python data1/zone.py ├─utils │ │ zone.py docker pull python:alpine docker run -it -v /d/1.source/pythonpath/python-learning/utils:/data1 python:alpine /bin/sh python data1/zone.py zone.py from datetime import datetime,timedelta,timezone TZ_BJ = timezone(timedelta(hours=8)) print(datetime.now()) print(datetime.now(TZ_BJ)) print(datetime(2021,12,20,17,tzinfo=TZ_BJ)) "},"python/email/m1.html":{"url":"python/email/m1.html","title":"邮件","keywords":"","body":"发邮件 注意：password不是邮箱密码，登录邮箱开通 POP3/SMTP服务 会获取一个免费的code import mimetypes import os import smtplib from email.header import Header from email.message import EmailMessage def send_email(server, email, password, to_list: str, subject, content, attach_path): \"\"\" 发送邮件 :param server:邮件服务器 :param email: 发送者邮件地址 :param password: 不是邮箱密码，登录邮箱开通 POP3/SMTP服务 会获取一个code :param to_list: 发送地址列表,多个用逗号隔开 :param subject: 主题 :param content: 发送邮件内容 :param attach_path: 发送邮件附件 :param debug_level: 发送邮件debug级别,默认为0 \"\"\" msg = EmailMessage() msg['From'] = email msg['To'] = to_list msg['Subject'] = Header(subject, 'utf-8').encode() msg.set_content(content, subtype='html', charset='utf-8', cte='8bit') if attach_path: ctype, encoding = mimetypes.guess_type(attach_path) if ctype is None or encoding is not None: # No guess could be made, or the file is encoded (compressed), so # use a generic bag-of-bits type. ctype = 'application/octet-stream' maintype, subtype = ctype.split('/', 1) with open(attach_path, 'rb') as fp: msg.add_attachment(fp.read(), maintype, subtype, filename=attach_path) with smtplib.SMTP_SSL(server) as smtp: # HELO向服务器标志用户身份 smtp.ehlo_or_helo_if_needed() # 登录邮箱服务器 smtp.login(email, password) smtp.send_message(msg) if __name__ == '__main__': send_email('smtp.163.com', 'xiaoxm_002@163.com', os.getenv('smtp_code'), 'xiaoxm_001@163.com', 'good morning', 'good', None) "},"python/str/m1.html":{"url":"python/str/m1.html","title":"字符串","keywords":"","body":"字符串 格式化的方式 填充零的方式 常用方法[编码,查找并替换,strip,split,isdecimal,isspace] import re # pytest -vs cainiao1/test_str.py def test_1(): # 1.格式化的方式 dog = 'dog' str1 = 'This is a %s' % dog str2 = 'This is {} {}'.format('a', dog) str3 = f'This is a {dog}' assert 'This is a dog' == str1, r'% format error' assert 'This is a dog' == str2, '{} format error' assert 'This is a dog' == str3, 'f-string format errorr' def test_2(): # 2.填充零的方式 price = 123 str1 = '%04d' % 123 str2 = str(123).rjust(4, '0') str3 = str(123).zfill(4) assert '0123' == str1, '% format error' assert '0123' == str2, 'rjust error' assert '0123' == str3, 'zfill error' def test_3(): # 3 编码 c = '中国' b1 = c.encode('utf-8') assert b'\\xe4\\xb8\\xad\\xe5\\x9b\\xbd' == b1, 'encode error' str1 = b1.decode('utf-8') assert '中国' == str1, 'decode error' def test_4(): # 4 startswith,find raw = 'hello world $1 $2' b1 = raw.startswith('hello') assert b1, 'startswith error' i1 = raw.find('$') i2 = raw.rfind('$') assert 12 == i1, 'find error' assert 15 == i2, 'rfind error' def test_5(): # 查找并替换 raw = 'hello world hello 1' str1 = raw.replace('hello', 'good', 1) assert 'good world hello 1' == str1, 'replace error' reg = re.compile(r'^hello') str2 = reg.sub('good', raw) assert 'good world hello 1' == str2, 'replace error' reg = re.compile(r'hello') str3 = reg.sub('good', raw, 1) assert 'good world hello 1' == str3, 'replace error' def test_6(): # strip raw = 'madam' str1 = raw.strip('am') assert 'd' == str1, 'strip error' def test_7(): # split raw = 'I am from jingzhou' a1 = raw.split(' ') assert {'I', 'am', 'from', '', 'jingzhou'} == set(a1), 'split error' a2 = re.split(r'\\s+', raw) assert {'I', 'am', 'from', 'jingzhou'} == set(a2), 'split re error' def test_8(): # 数字 isdecimal 不可以汉字,isdigit 不可以汉字, isnumeric可以汉字 # 我会优先用isdecimal,因为比较干净 raw1 = '123' raw2 = '五' assert raw1.isdecimal() == raw1.isdigit( ) == raw1.isnumeric() == True, 'isdecimal error' assert not raw2.isdecimal(), 'isdecimal error' assert not raw2.isdigit(), 'isdigit error' assert raw2.isnumeric(), 'isnumeric error' def test_9(): # isspace raw = ' ' assert raw.isspace(), 'isspace error' "},"python/param/m1.html":{"url":"python/param/m1.html","title":"参数","keywords":"","body":"可变参数 解读args和kwargs def args(*args): return args def kwargs(**kwargs): return kwargs def test_kwargs(): v = kwargs() assert {} == v, 'kwargs 空参错误' param = {'a': 1, 'b': 2} v = kwargs(**param) assert {'a': 1, 'b': 2} == v, 'kwargs 传字典错误' v = kwargs(a=1, b=2) assert {'a': 1, 'b': 2} == v, 'kwargs 传a=1格式错误' def test_args(): v = args() assert () == v, 'args 空参数错误' params = (1,) v = args(*params) assert (1,) == v, 'args 1 tuple error' params = (1, 2, 3) v = args(*params) assert (1, 2, 3) == v, 'args 3 tuple error' params = [1, 2, 3] v = args(*params) assert (1, 2, 3) == v, 'args 3 list error' params = set((1, 2, 3)) v = args(*params) assert (1, 2, 3) == v, 'args 3 set error' params = range(1, 4) v = args(*params) assert (1, 2, 3) == v, 'args range(1,4) error' params = 'a' v = args(*params) assert ('a',) == v, 'args 1 str error' params = 'a', 'b' v = args(*params) assert ('a', 'b') == v, 'args 1 str error' "},"python/dict/m1.html":{"url":"python/dict/m1.html","title":"字典","keywords":"","body":"字典 增删改查 in, enumerate setdefault,update,get,pop,popitem sort 浅复制 和 深度复制 方法：dict(p) import copy def test_1(): # 增删改查 dict1 = {'a': 1, 'b': 2} dict1['c'] = 3 assert {'a': 1, 'b': 2, 'c': 3} == dict1, 'dict 新增失败' del dict1['b'] assert {'a': 1, 'c': 3} == dict1, 'dict 删除失败' dict1['c'] = 4 assert {'a': 1, 'c': 4} == dict1, 'dict 修改失败' c = dict1['c'] assert 4 == c, 'dict 查询失败' pass def test_2(): # in, enumerate dict1 = {'a': 1, 'b': 2} indexs = [i for i, v in enumerate(dict1.items()) if v[0] == 'b'] assert [1] == indexs, 'dict enumerate error' assert 'a' in dict1, 'dict in error' pass def test_3(): # setdefault,update,get,pop,popitem # setdefault 如果有没则增加，有则不变 dict1 = {'a': 1, 'b': 2} dict1.setdefault('c', 4) assert {'a': 1, 'b': 2, 'c': 4}, 'dict setdefault error' dict1.setdefault('b', 1) assert {'a': 1, 'b': 2, 'c': 4} == dict1, 'dict setdefault b error' dict1.update({'c': 5}) assert {'a': 1, 'b': 2, 'c': 5} == dict1, 'dict update error' c = dict1.get('c', 1) assert 5 == c, 'dict get error' f = dict1.get('f', 1) assert 1 == f, 'dict get f error' dict1.pop('c') assert {'a': 1, 'b': 2} == dict1, 'dict pop error' dict1.popitem() assert {'a': 1} == dict1, 'dict popitem error' pass def test_4(): # sort dict1 = {'b': 2, 'a': 1} dict2 = dict(sorted(dict1.items(), key=lambda kv: kv[0])) assert {'a': 1, 'b': 2} == dict2, 'dict sorted 1 error' dict1 = {'b': 2, 'a': 1, 'c': 1} dict2 = dict(sorted(dict1.items(), key=lambda kv: (kv[1], kv[0]))) assert {'a': 1, 'c': 1, 'b': 2} pass def test_5(): # 浅复制 和 深度复制 # 1.浅复制：不改变原字典 dict1 = {'a': 1, 'b': 2} dict2 = dict1.copy() dict2.update({'b': 1}) assert {'a': 1, 'b': 2} == dict1, 'dict copy 1 error' assert {'a': 1, 'b': 1} == dict2, 'dict copy 1.1 error' # 2.浅复制：改变原字典--子对象 dict1 = {'a': 1, 'b': {'c': 1}} dict2 = dict1.copy() dict2['b'].setdefault('d', 2) assert {'a': 1, 'b': {'c': 1, 'd': 2}} == dict1, 'dict copy 2 error' assert {'a': 1, 'b': {'c': 1, 'd': 2}} == dict2, 'dict copy 2.1 error' # 3.浅复制：不改变原字典 dict1 = {'a': 1, 'b': {'c': 1}} dict2 = copy.deepcopy(dict1) dict2['b'].setdefault('d', 2) assert {'a': 1, 'b': {'c': 1}} == dict1, 'dict copy 3 error' assert {'a': 1, 'b': {'c': 1, 'd': 2}} == dict2, 'dict copy 3.1 error' pass def test_6(): # 方法：dict(p) dict1 = dict() assert {} == dict1, 'dict new 1 error' dict1 = dict({'a': 1}) assert {'a': 1} == dict1, 'dict new 2 error' dict1 = dict([('a', 1), ('b', 2)]) assert {'a': 1, 'b': 2} == dict1, 'dict new 3 error' dict1 = dict(a=1, b=2) assert {'a': 1, 'b': 2} == dict1, 'dict new 4 error' params = {'a': 1, 'b': 2} dict1 = dict(**params) assert {'a': 1, 'b': 2} == dict1, 'dict new 5 error' pass "},"python/list/m1.html":{"url":"python/list/m1.html","title":"列表","keywords":"","body":"列表 增删改查，insert,pop 方法：list(p), + , in,enumerate append 和 extend list.index(obj),sort 浅复制 和 深度复制 import copy # pytest -vs .\\cainiao1\\test_list.py def test_1(): # 增删改查，增和删 list1 = ['a', 'b', 'c'] list1.append('d') assert ['a', 'b', 'c', 'd'] == list1, 'append error' del list1[0] assert ['b', 'c', 'd'] == list1, 'del error' list1[0] = 'e' assert ['e', 'c', 'd'] == list1, 'update error' c = list1[1] assert 'c' == c, 'query error' list1.insert(1, 'f') assert ['e', 'f', 'c', 'd'] == list1, 'insert error' list1.pop(1) assert ['e', 'c', 'd'] == list1, 'pop error' list1.pop() assert ['e', 'c'] == list1, 'pop 2 error' def test_2(): # 方法：list(p), + , in,enumerate list1 = list('abc') assert ['a', 'b', 'c'] == list1, 'list(p) 方法错误' list1 = list1+['d', 'e'] assert ['a', 'b', 'c', 'd', 'e'] == list1, 'list相加错误' assert 'a' in list1, 'list的in操作错误' list2 = list({'name': 'a', 'age': 19}) assert ['name', 'age'] == list2, 'list(p) 方法错误' indexs = [i for i, _ in enumerate(list2)] assert [0, 1] == indexs, 'enumerate error' def test_3(): # append 和 extend list1 = ['a', 'b', 'c'] list2 = ['d', 'e'] list_append = list1.copy() list_append.append(list2) assert ['a', 'b', 'c', ['d', 'e']] == list_append, 'list append方法错误' list_extend = list1.copy() list_extend.extend(list2) assert ['a', 'b', 'c', 'd', 'e'] == list_extend, 'list extentd 方法错误' def test_4(): # list.index(obj),sort list1 = ['b', 'c', 'a'] i = 0 for v in list1: assert list1.index(v) == i, f'list index方法错误 i:{i},v:{v}' i += 1 list1.sort() assert ['a', 'b', 'c'] == list1, 'list sort 方法错误' list1.sort(reverse=True) assert ['c', 'b', 'a'] == list1, 'list sort reverse 方法错误' list2 = [{'name': 'b', 'age': 20}, { 'name': 'a', 'age': 18}, {'name': 'b', 'age': 19}] list2.sort(key=lambda kv: kv['name']) assert {'name': 'a', 'age': 18} == list2[0], 'list sort key方法错误' list2.sort(key=lambda kv: kv['age']) assert [{'name': 'a', 'age': 18}, {'name': 'b', 'age': 19}, {'name': 'b', 'age': 20}] == list2, 'list sort key 方法错误' list2.sort(key=lambda kv: (kv['name'], kv['age'])) assert [{'name': 'a', 'age': 18}, {'name': 'b', 'age': 19}, {'name': 'b', 'age': 20}] == list2, 'list sort key 方法错误' def test_5(): # 浅复制 和 深度复制 # 只有list1中的数据是引用类型的时候，才会考虑deepcopy，否则，平常的copy就行 list1 = ['a', 'b', 'c', ['e', 'f']] list2 = list1 list3 = list1[:] list4 = list1.copy() list5 = [i for i in list1] list6 = copy.deepcopy(list1) assert id(list1) == id(list2), '== error' assert id(list1) != id(list3), '[:] error' assert id(list1) != id(list4), 'list copy error' assert id(list1) != id(list5), 'for error' assert id(list1) != id(list6), 'deepcopy error' list6[3][0] = 'd' assert ['a', 'b', 'c', ['e', 'f']] == list1, 'deepcopy 1 error' assert ['a', 'b', 'c', ['d', 'f']] == list6, 'deepcopy 2 error' "},"python/set/m1.html":{"url":"python/set/m1.html","title":"集合","keywords":"","body":"集合 增删改查，discard, | & ^, difference,union,intersection,symmetric_difference 方法：set(p), in,enumerate sorted 浅复制 和 深度复制 import copy # pytest -vs cainiao1/test_set.py def test_1(): # 增删改查，discard, set1 = {1, 2} set1.add(3) assert {1, 2, 3} == set1, 'add error' set1.remove(2) assert {1, 3} == set1, 'remove error' set1.update({1, 4}) assert {1, 3, 4} == set1, 'update 1 error' set1.update((5,)) assert {1, 3, 4, 5} == set1, 'update 2 error' e = 5 if 5 in set1 else None assert e == 5, 'in error' set1.discard(5) assert {1, 3, 4} == set1, 'discart error' pass def test_2(): # - | & ^, difference,union,intersection,symmetric_difference set1 = {1, 2, 3} set2 = {2, 3, 4} setx = set1-set2 assert {1} == setx, '- error' setx = set1 | set2 assert {1, 2, 3, 4} == setx, '| error' setx = set1 & set2 assert {2, 3} == setx, '& error' setx = set1 ^ set2 assert {1, 4} == setx, '^ error' setx = set1.difference(set2) assert {1} == setx, '- error' setx = set1.union(set2) assert {1, 2, 3, 4} == setx, '| error' setx = set1.intersection(set2) assert {2, 3} == setx, '& error' setx = set1.symmetric_difference(set2) assert {1, 4} == setx, '^ error' pass def test_3(): # 方法：set(p), in,enumerate set1 = set([1, 2]) assert {1, 2} == set1, '[1,2] error' set1 = set((1,)) assert {1} == set1, r'{1} error' set1 = set('abc') assert {'a', 'b', 'c'} == set1, 'abc error' set_indexs = [i for i, v in enumerate(set1)] assert [0, 1, 2] == set_indexs, 'enumerate error' pass def test_4(): # sorted set1 = {'b', 'a', 'c'} sorted(set1) assert {'a', 'b', 'c'} == set1, 'sorted error' pass class Person: def __init__(self, a: int, b: int): self.a = a self.b = b pass def test_5(): # 浅复制 和 深度复制 set1 = {1, Person(2, 3)} set2 = {i for i in set1} set2.update({4}) assert not {4}.issubset(set1), 'copy 1 error' assert {4}.issubset(set2), 'copy 2 error' set2 = set1.copy() for i in set2: if type(i) == Person: i.a = 4 p1: Person = [i for i in set1 if type(i) == Person][0] p2: Person = [i for i in set2 if type(i) == Person][0] assert 4 == p1.a, 'copy 3 error' assert 4 == p2.a, 'copy 4 error' set1 = {1, Person(2, 3)} set2 = copy.deepcopy(set1) for i in set2: if type(i) == Person: i.a = 4 p3: Person = [i for i in set1 if type(i) == Person][0] p4: Person = [i for i in set2 if type(i) == Person][0] assert 2 == p3.a, 'copy 3 error' assert 4 == p4.a, 'copy 4 error' pass "},"python/re/m1.html":{"url":"python/re/m1.html","title":"正则","keywords":"","body":"re 基本使用 ''' . \\w \\s \\d a|b () [...] {} * + 1. 常用元字符 . 匹配除换行符以外的任意字符 \\w 匹配字母或数字或下划线 \\s 匹配任意的空白符 \\d 匹配数字 \\n 匹配一个换行符 \\t 匹配一个制表符 ^ 匹配字符串的开始 $ 匹配字符串的结尾 \\W 匹配非字母或数字或下划线 \\D 匹配非数字 \\S 匹配非空白符 a|b 匹配字符a或字符b () 匹配括号内的表达式，也表示一个组 [...] 匹配字符组中的字符 [^...] 匹配除了字符组中字符的所有字符 2. 量词：控制前面的元字符出现的次数 * 重复零次或更多次 + 重复一次或更多次 ？ 重复零次或一次 {n} 重复n次 {n，} 重复n次货更多次 3. 贪婪匹配和惰性匹配 .* 贪婪匹配 .*? 非贪婪匹配 ''' import re def test_dot(): data1 = 'hello \\ world' pattern = re.compile(r'.+') res_list = pattern.findall(data1) assert 'hello world' == res_list[0], 're dot error' def test_dot2(): # 有时候需要 . 能匹配所有字符,包括换行符, 就需要带上参数 re.S data1 = '' # (.+) 括号说明: 正常会取整个,加括号之后,就只取括号里面的了 ptn = re.compile(r'', re.S) res_list = ptn.findall(data1) assert 'hello \\ world' == res_list[0], 're dot 2 error' def test_w(): data1 = 'ab_@.121' # + 表示重复一次或者更多次,就是说如果条件一直符合的话,就联系输出,比如:ab_ ptn = re.compile(r'\\w+') res_list = ptn.findall(data1) assert ['ab_', '121'] == res_list, 're w error' def test_s(): data1 = 'a b\\tc\\n d$#' ptn = re.compile(r'\\s+') res_list = ptn.findall(data1) assert [' ', '\\t', '\\n '] == res_list, 're s error' def test_d(): data1 = 'yidong 10086,liantong 10010' ptn = re.compile(r'\\d+') res_list = ptn.findall(data1) assert ['10086', '10010'] == res_list, 're d error' def test_start(): data1 = 'ab1ab2' ptn = re.compile(r'ab\\d') res_list = ptn.findall(data1) assert ['ab1', 'ab2'] == res_list, 're ^ error' # ^ 表示只匹配字符串的开始 data1 = 'ab1ab2' ptn = re.compile(r'^ab\\d') res_list = ptn.findall(data1) assert ['ab1'] == res_list, 're ^ 2 error' def test_end(): data1 = '1ab2ab' ptn = re.compile(r'\\dab$') res_list = ptn.findall(data1) assert ['2ab'] == res_list, 're $ error' def test_and(): data1 = '12a_3$dc' ptn = re.compile(r'\\d+|a|d|c') res_list = ptn.findall(data1) assert ['12', 'a', '3', 'd', 'c'] == res_list, 're | error' def test_bracket(): data1 = '' ptn = re.compile(r'') res_list = ptn.findall(data1) assert ('1', 'xiaoxinmiao') == res_list[0], 're () error' def test_bracket2(): # 可以设置分组名 data1 = '' ptn = re.compile(r'.*?)\" name=\"(?P.*?)\"/>') iter_obj = ptn.finditer(data1) res_obj = iter_obj.__next__() assert '1' == res_obj.group( 'id') and 'xiaoxinmiao' == res_obj.group('name'), 're () error' def test_bracket3(): # 可以设置分组名 data1 = '' ptn = re.compile( r'.*?)\" name=\"(?P.*?)\"/>') iter_obj = ptn.finditer(data1) ids, names = [], [] for i in iter_obj: ids.append(i.group('id')) names.append(i.group('name')) assert ['1', '2'] == ids and ['miao1', 'miao2'] == names, 're () error' def test_bracket_mid(): data1 = '12dss#$$fwe564_' ptn = re.compile(r'[1-9a-z_$]+') res_list = ptn.findall(data1) assert ['12dss', '$$fwe564_'] == res_list, 're [] error' def test_bracket_mid2(): data1 = '12dss#$$fwe564_' # [^] 表示不匹配里面的任何数 ptn = re.compile(r'[^1-9a-z_$]+') res_list = ptn.findall(data1) assert ['#'] == res_list, 're [] error' def test_star(): data1 = '' # 这不是我们期待的结果 res_list = re.findall(r'', data1, re.S) assert [] == res_list, 're + error' # 这是我们期待的结果,做了两个分组,就应该返回两组数据 res_list = re.findall(r'', data1, re.S) assert ('', '') == res_list[0], 're + error' def test_star2(): # .* 贪婪 data1 = '我爱北京天安门,天安门上太阳升.' res_list = re.findall(r'我爱(.*)天安门', data1) assert ['北京天安门,'] == res_list, 're .* error' # .*? 非贪婪 res_list = re.findall(r'我爱(.*?)天安门', data1) assert ['北京'] == res_list, 're .* error' def test_bracket_big(): # 只有两位数字才符合要求 data1 = 'a1b12c134d1234e' res_list = re.findall(r'\\d{2}', data1) assert ['12', '13', '12', '34'] == res_list, r're {} error' # 两位,以及两位以上的数字都符合要求 data1 = 'a1b12c134d1234e' res_list = re.findall(r'\\d{2,}', data1) assert ['12', '134', '1234'] == res_list, r're {} error' 替换和拆分 import re def test_split(): data1 = 'you are \\ the best' res_list=re.split(r'\\s+',data1) assert ['you','are','the','best']==res_list,'re split error' def test_sub(): data1 ='my mobile is 15811112222' num = re.sub(r'^.*is ','',data1) assert '15811112222'==num,'re sub error' num = re.sub(r'\\D+','',data1) assert '15811112222'==num,'re sub error' def test_sub2(): data1 = 'a:1,b:2,c:3' def multi(matched): v = int(matched.group()) return str(v*2) res=re.sub(r'\\d+',multi,data1) assert 'a:2,b:4,c:6'==res,'re sub2 error' "},"python/serialize/m1.html":{"url":"python/serialize/m1.html","title":"序列化","keywords":"","body":"json序列化 pytest执行 简单对象 p = Person('xiao') json1 = json.dumps(p, default=Person.to_dict) p2 = json.loads(json1, object_hook=Person.from_dict) import json from typing import Dict class Person: def __init__(self, name: str = 'xiaomiao'): self.name = name @staticmethod def to_dict(obj: object): return obj.__dict__ @classmethod def from_dict(cls, dict: Dict): p = cls() p.__dict__ = dict return p class Female(Person): def __init__(self, name: str = 'xiao', sex: int = 1): self.name = name self.sex = sex def test_1(): p = Person('xiao') json1 = json.dumps(p, default=Person.to_dict) assert '{\"name\": \"xiao\"}' == json1, 'json dump error' p2 = json.loads(json1, object_hook=Person.from_dict) assert p.__dict__ == p2.__dict__, 'json loads error' def test_2(): p_list = [Person('xiao1'), Person('xiao2')] json1 = json.dumps(p_list, default=Person.to_dict) assert '[{\"name\": \"xiao1\"}, {\"name\": \"xiao2\"}]' == json1, 'json dump 2 error' p2_list = json.loads(json1, object_hook=Person.from_dict) assert p_list[0].__dict__ == p2_list[0].__dict__ and p_list[1].__dict__ == p2_list[1].__dict__, 'json loads 2 error' def test_3(): p = Female(name='xiao1', sex=1) json1 = json.dumps(p, default=Female.to_dict) assert '{\"name\": \"xiao1\", \"sex\": 1}' == json1, 'json dump error' p2 = json.loads(json1, object_hook=Female.from_dict) assert p.__dict__ == p2.__dict__, 'json loads error' 嵌套对象 局限：因为要人为添加一个fullname字段，所以，要 先序列化到文件，然后再反序列化 p = Person('xiao') p.p1 = Person1('xinmiao') json1 = json.dumps(p, default=Person.to_dict) p2 = json.loads(json1, object_hook=Person.from_dict) import importlib import json from typing import Dict class Person1: def __init__(self, name: str = 'xiao'): self.name = name class Person: def __init__(self, name: str = 'good'): self.name = name self.p1 = None @staticmethod def to_dict_pure(obj: object): return obj.__dict__ @staticmethod def to_dict(obj: object): obj.__dict__.update( {'fullname': f'{obj.__module__}.{obj.__class__.__name__}'}) return obj.__dict__ @staticmethod def from_dict(dict: Dict): module, classname = dict['fullname'].rsplit('.', 1) p = getattr(importlib.import_module(module), classname)() p.__dict__ = dict return p def test_1(): p = Person('xiao') p.p1 = Person1('xinmiao') json1 = json.dumps(p, default=Person.to_dict) assert '{\"name\": \"xiao\", \"p1\": {\"name\": \"xinmiao\", \"fullname\": \"test_obj_conv_2.Person1\"}, ' +\\ '\"fullname\": \"test_obj_conv_2.Person\"}' == json1, 'json dumps error' p2 = json.loads(json1, object_hook=Person.from_dict) assert p.__dict__['name'] == p2.__dict__['name'] \\ and p.__dict__['p1'].__dict__ == p2.__dict__['p1'].__dict__, 'json loads error' def test_2(): p1 = Person('xiao1') p1.p1 = Person1('xin1') p2 = Person('xiao2') p2.p1 = Person1('xin2') p_list = [p1, p2] json1 = json.dumps(p_list, default=Person.to_dict) assert '[{\"name\": \"xiao1\", \"p1\": {\"name\": \"xin1\", \"fullname\": \"test_obj_conv_2.Person1\"},' +\\ ' \"fullname\": \"test_obj_conv_2.Person\"}, {\"name\": \"xiao2\", \"p1\": {\"name\": \"xin2\", ' +\\ '\"fullname\": \"test_obj_conv_2.Person1\"}, \"fullname\": \"test_obj_conv_2.Person\"}]', 'json dumps 2 error' p2_list = json.loads(json1, object_hook=Person.from_dict) assert p_list[0].__dict__['name'] == p2_list[0].__dict__['name'] \\ and p_list[0].__dict__['p1'].__dict__ == p2_list[0].__dict__['p1'].__dict__ \\ and p_list[1].__dict__['name'] == p2_list[1].__dict__['name'] \\ and p_list[1].__dict__['p1'].__dict__ == p2_list[1].__dict__['p1'].__dict__, 'json loads 2 error' pickle 使用简单，不做过多介绍 主要说明一下 pickle和json嵌套对象序列化的区别，pickle序列化到文件中是二进制格式，而且还会受到python版本的影响，所以还是建议用json嵌套对象序列化的方式 "},"python/pypy/m1.html":{"url":"python/pypy/m1.html","title":"pypy安装","keywords":"","body":"pypy 安装pypy 下载 https://www.pypy.org/download.html 解压到一个目录: 比如我的windows目录是 D:\\2.file\\pypy3.8-v7.3.7-win64 设置环境变量: 将上面的路径放到path路径中 安装pip pypy3 -m ensurepip 安装其他包 pypy3 -mpip install pyexecjs 引用 https://www.cxyzjd.com/article/SunStrongInChina/111238778 https://github.com/mozillazg/pypy "},"golang/":{"url":"golang/","title":"golang","keywords":"","body":" golang hello 加速 hello-mod "},"golang/hello/m1.html":{"url":"golang/hello/m1.html","title":"hello","keywords":"","body":"hello 下载并安装golang：https://golang.org/dl/ 或者 https://golang.google.cn/dl/ 下载并安装编译器 vscode：https://code.visualstudio.com/ 设置环境变量 GO111MODULE=on 创建并运行第一个go程序 在任何第一个地方创建一个文件main.go，并编写下面的代码 用vscode打开，在终端运行go run main.go package main import \"fmt\" func main() { /* 这是我的第一个简单的程序 */ fmt.Println(\"hello world\") } 输出 PS D:\\1.source\\gopath\\go-first> go run main.go hello world 引用：https://www.runoob.com/go/go-environment.html "},"golang/speed/m1.html":{"url":"golang/speed/m1.html","title":"加速","keywords":"","body":"加速执行go get 配置环境变量 GOPROXY=https://goproxy.cn "},"golang/hello-mod/m1.html":{"url":"golang/hello-mod/m1.html","title":"hello-mod","keywords":"","body":"创建一个go mod项目 新建一个文件夹go-mod-first和文件main.go 在main.go编写文件 package main import ( \"fmt\" \"github.com/relax-space/go-kit/base\" ) func main() { fmt.Println(\"hello go mod\") fmt.Println(base.ToFixed(1.21512)) } 在vscode执行如下操作 执行 go get github.com/relax-space/go-kit 执行 go mod init go-mod-first 执行 go mod tidy 运行项目 go run main.go sample代码 https://github.com/relax-space/go-mod-first "},"vip/":{"url":"vip/","title":"vip","keywords":"","body":"一些私房菜程序, 需要的加微信: xiaoxm_001, 备注: gitbook "}}